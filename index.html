<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Master 3D - Ultimate</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;900&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-main: #4d73ff;
            --grid-bg: #1a1a3a;
            --cell-empty: #232344;
            --text-main: #ffffff;
            --accent-yellow: #ffc800;
            --score-bg: #334db3;
            --bevel-light: rgba(255, 255, 255, 0.5);
            --bevel-shadow: rgba(0, 0, 0, 0.25);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; padding: 0;
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            height: 100vh; height: 100dvh;
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
        }

        /* --- Screens --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1; opacity: 0; transition: opacity 0.3s ease; padding: 20px;
        }
        .screen.active { display: flex; opacity: 1; }

        h1 {
            font-size: 3.5rem; text-shadow: 0 4px 0 rgba(0,0,0,0.2);
            margin-bottom: 2rem; text-align: center; color: white; font-weight: 900;
        }

        /* Buttons */
        .main-button {
            padding: 15px 60px; font-size: 1.5rem; font-weight: 900;
            font-family: 'Nunito', sans-serif; border: none; border-radius: 15px;
            background-color: var(--accent-yellow); color: #4d2a00; cursor: pointer;
            box-shadow: 0 6px 0 #cc9f00, 0 10px 20px rgba(0,0,0,0.2);
            transition: transform 0.1s; margin-bottom: 15px;
        }
        .main-button:active { transform: translateY(6px); box-shadow: 0 0 0 #cc9f00; }

        .control-button {
            background: rgba(255, 255, 255, 0.2); border: none; color: white;
            width: 50px; height: 50px; border-radius: 12px; cursor: pointer;
            font-size: 1.4rem; margin: 0 8px; display: inline-flex;
            justify-content: center; align-items: center; box-shadow: 0 4px 0 rgba(0,0,0,0.2);
            position: relative;
        }
        .control-button:active { transform: translateY(4px); box-shadow: none; }

        /* Custom Music Slash Style */
        .music-off .fa-music {
            position: relative;
        }
        .music-off .fa-music::after {
            content: '';
            position: absolute;
            width: 120%;
            height: 3px;
            background-color: #ffffff; /* UPDATED: Changed from Red to White */
            top: 50%;
            left: -10%;
            transform: rotate(-45deg);
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        /* --- Header --- */
        .header {
            width: 100%; max-width: 450px; display: flex; justify-content: space-between;
            align-items: center; margin-bottom: 20px; padding: 0 10px;
        }
        .score-group-left {
            display: flex; align-items: center; font-size: 1.8rem; font-weight: 900;
            color: var(--accent-yellow); text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .crown-icon { margin-right: 10px; font-size: 1.5rem; }
        .current-score-pill {
            background-color: var(--score-bg); padding: 5px 25px; border-radius: 20px;
            font-size: 1.5rem; font-weight: 900; color: white;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3); min-width: 100px; text-align: center;
        }
        .settings-btn {
            background: none; border: none; color: white; font-size: 1.8rem;
            cursor: pointer; text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* --- Board --- */
        #game-board-container {
            padding: 10px; background: var(--grid-bg); border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); width: 95vw; max-width: 420px;
            aspect-ratio: 1 / 1; display: flex; align-items: center; justify-content: center;
            position: relative;
        }
        #game-board {
            display: grid; grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr); gap: 2px; width: 100%; height: 100%;
        }
        .grid-cell {
            background-color: var(--cell-empty); border-radius: 4px; width: 100%; height: 100%;
            transition: transform 0.1s;
        }

        /* 3D Block Look */
        .block-3d {
            position: relative;
            box-shadow: inset 4px 4px 0px var(--bevel-light), inset -4px -4px 0px var(--bevel-shadow);
            border-radius: 4px;
        }
        
        /* Blast Animations */
        .grid-cell.white-flash {
            background-color: #ffffff !important; box-shadow: 0 0 10px #ffffff;
            z-index: 10; transition: background-color 0.1s;
        }
        .grid-cell.spin-out { animation: spinShrinkAnim 0.5s ease-in forwards; }
        @keyframes spinShrinkAnim {
            0% { transform: scale(1) rotateY(0deg); opacity: 1; background-color: #ffffff; }
            100% { transform: scale(0) rotateY(180deg); opacity: 0; background-color: #ffffff; }
        }

        /* --- Preview & Drag --- */
        #next-blocks-container {
            margin-top: 40px; display: flex; justify-content: space-around;
            width: 100%; max-width: 400px; height: 90px;
        }
        .block-preview {
            flex: 1; display: flex; justify-content: center; align-items: center;
            position: relative; transition: opacity 0.3s;
        }
        
        .block-preview.hidden-source .preview-inner { 
            opacity: 0 !important; 
            visibility: hidden !important; 
        }
        
        /* Unplayable Block Style */
        .block-preview.unplayable {
            opacity: 0.4;
            filter: grayscale(0.5);
        }

        .slide-up-enter {
            animation: slideUpBounce 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes slideUpBounce {
            from { opacity: 0; transform: translateY(50px) scale(0.5); }
            to { opacity: 1; transform: translateY(0) scale(0.8); }
        }

        .preview-inner {
            display: grid; gap: 2px; transform: scale(0.8); pointer-events: none;
        }
        .preview-cell { width: 25px; height: 25px; border-radius: 4px; }

        #drag-follower {
            position: fixed; pointer-events: none; z-index: 1000; display: none;
            gap: 2px; transform: translate(-50%, -150%);
            filter: drop-shadow(0 15px 15px rgba(0,0,0,0.4));
        }
        
        #drag-follower.faded {
            opacity: 0.4;
            filter: grayscale(0.5);
        }
        
        .drag-cell { border-radius: 4px; }
        .grid-cell.ghost {
            background-color: rgba(255, 255, 255, 0.3) !important; box-shadow: none;
        }

        /* --- Popups --- */
        .popup {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); z-index: 100;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        .popup.active { opacity: 1; pointer-events: auto; }

        .popup-content {
            background: var(--bg-main); padding: 30px; border-radius: 20px;
            text-align: center; width: 85%; max-width: 320px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            border: 4px solid rgba(255,255,255,0.2);
        }
        
        .popup-btn {
            background: white; color: var(--bg-main); padding: 12px 30px;
            margin: 10px 5px; border-radius: 10px; font-weight: 900; border: none;
            cursor: pointer; font-size: 1.1rem; box-shadow: 0 4px 0 #ccc;
            transition: 0.1s; display: block; width: 100%;
        }
        .popup-btn:active { transform: translateY(4px); box-shadow: none; }
        .popup-btn.secondary { background: #334db3; color: white; box-shadow: 0 4px 0 #223377; }

        #floating-score {
            position: fixed; color: #fff; font-weight: 900; font-size: 2.5rem;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5); pointer-events: none; z-index: 50; opacity: 0;
        }
        .score-animating { animation: floatUp 0.8s forwards; }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-80px) scale(1.2); opacity: 0; }
        }
          .note{
    margin-top:12px;
    color:rgba(246,248,255,0.7);
    font-size:13px;
    text-align:center;
    </style>
</head>
<body>

    <audio id="snd-bg" src="music.mp3" loop></audio>
    <audio id="snd-click" src="click.mp3"></audio>
    <audio id="snd-pickup" src="pickup.mp3"></audio>
    <audio id="snd-drop" src="drop.mp3"></audio>
    <audio id="snd-error" src="error.mp3"></audio>
    <audio id="snd-blast" src="blast.mp3"></audio>
    <audio id="snd-gameover" src="gameover.mp3"></audio>
    <audio id="snd-start" src="start.mp3"></audio>

    <div id="drag-follower"></div>
    
    <div id="home-screen" class="screen active">
        <h1>BLOCK<br>PUZZLE</h1>
        <button id="start-game-btn" class="main-button">PLAY</button>
        
        <div class="controls-container" style="margin-top: 30px;">
            <button id="sound-btn" class="control-button"><i class="fas fa-volume-up"></i></button>
            <button id="music-btn" class="control-button"><i class="fas fa-music"></i></button>
            <button id="how-to-play-home-btn" class="control-button"><i class="fas fa-question"></i></button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div class="header">
            <div class="score-group-left">
                <i class="fas fa-crown crown-icon"></i>
                <span id="high-score">0</span>
            </div>
            <div class="current-score-pill">
                <span id="current-score">0</span>
            </div>
            <button id="pause-btn" class="settings-btn"><i class="fas fa-pause"></i></button>
        </div>

        <div id="game-board-container">
            <div id="game-board"></div>
        </div>

        <div id="next-blocks-container">
            <div class="block-preview" id="block-0"></div>
            <div class="block-preview" id="block-1"></div>
            <div class="block-preview" id="block-2"></div>
        </div>

        <div id="floating-score"></div>

        <div id="pause-popup" class="popup">
            <div class="popup-content">
                <h2>PAUSED</h2>
                <button id="resume-btn" class="popup-btn">Resume</button>
                <button id="restart-btn-pause" class="popup-btn secondary" style="background:#ffc800; color:#4d2a00; box-shadow:0 4px 0 #cc9f00;">Restart</button>
                <button id="home-btn-pause" class="popup-btn secondary">Exit</button>
            </div>
        </div>

        <div id="game-over-popup" class="popup">
            <div class="popup-content">
                <h2 style="color:#ff6b6b; margin-top:0;">GAME OVER</h2>
                <div style="margin-bottom:20px;">
                    <p>Score: <span id="final-score" style="font-weight:bold; font-size:1.2rem;">0</span></p>
                </div>
                <button id="new-game-btn" class="popup-btn">Try Again</button>
                <button id="go-home-btn" class="popup-btn secondary">Home</button>
            </div>
        </div>
        
        <div id="how-to-play-popup" class="popup">
            <div class="popup-content">
                <h2>How To Play</h2>
                <div style="text-align: left; font-size: 16px; line-height: 1.6; margin-bottom:20px;">
                    <ul>
                    <li>Drag blocks onto the grid.</li>

<li>Complete full<b> rows or columns </b>to clear them and score points.</li>

<li>Space is limitedâ€”the round ends when no moves are left.</li>
<li>Use strategy to create combos and maximize rewards.</li>
</ul>

                </div>
                <button id="how-to-ok-btn" class="popup-btn">Got it</button>
                <div class="note" >Tip: Clearing multiple lines in succession yields larger combo bonuses. </div>
            </div>
        </div>
    </div>

    <script>
        /* --- SOUND MANAGER (With Persistence) --- */
        const SoundManager = {
            enabled: true,
            musicEnabled: true,
            
            elements: {
                bg: document.getElementById('snd-bg'),
                click: document.getElementById('snd-click'),
                pickup: document.getElementById('snd-pickup'),
                drop: document.getElementById('snd-drop'),
                error: document.getElementById('snd-error'),
                blast: document.getElementById('snd-blast'),
                gameover: document.getElementById('snd-gameover'),
                start: document.getElementById('snd-start')
            },

            init() {
                this.elements.bg.volume = 0.5;
                Object.values(this.elements).forEach(el => el.load());

                // Check saved music preference on startup
                const savedMusic = localStorage.getItem('bm3d_music_pref');
                const musicBtn = document.getElementById('music-btn');
                
                if (savedMusic === 'off') {
                    this.musicEnabled = false;
                    musicBtn.classList.add('music-off'); // Show line
                } else {
                    this.musicEnabled = true; // Default
                    musicBtn.classList.remove('music-off');
                }
            },

            playMusic() {
                if(this.musicEnabled) {
                    this.elements.bg.play().catch(e => {
                        console.log("Music play failed:", e);
                    });
                }
            },

            play(name) {
                if(!this.enabled) return;
                const el = this.elements[name];
                if(el) {
                    el.currentTime = 0;
                    el.play().catch(()=>{});
                }
            },

            toggleSound() {
                this.enabled = !this.enabled;
                return this.enabled;
            },

            toggleMusic() {
                this.musicEnabled = !this.musicEnabled;
                
                // Save preference
                localStorage.setItem('bm3d_music_pref', this.musicEnabled ? 'on' : 'off');

                if(this.musicEnabled) {
                    this.elements.bg.play().catch(()=>{});
                } else {
                    this.elements.bg.pause();
                }
                return this.musicEnabled;
            }
        };

        SoundManager.init();

        /* --- CONFIG & STATE --- */
        const GRID_SIZE = 10;
        let gameGrid = [];
        let availablePieces = []; 
        let score = 0;
        let displayScore = 0;
        
        let highScore = 0; 
        let displayHighScore = 0; // For animation
        
        let isGameActive = false; 
        let scoreAnimFrame;
        let highScoreAnimFrame; // New animation frame

        const boardEl = document.getElementById('game-board');
        const scoreEl = document.getElementById('current-score');
        const highScoreEl = document.getElementById('high-score');
        const dragFollower = document.getElementById('drag-follower');
        const floatingScore = document.getElementById('floating-score');
        const startBtn = document.getElementById('start-game-btn');

        const PIECES = [
            { shape: [[1, 1, 1, 1]], color: '#00dcff' }, 
            { shape: [[1, 1], [1, 1]], color: '#ffcc00' }, 
            { shape: [[1, 0], [1, 0], [1, 1]], color: '#ff0055' }, 
            { shape: [[1, 1, 1], [0, 1, 0]], color: '#bc00ff' }, 
            { shape: [[1, 1], [0, 1], [0, 1]], color: '#ff6a00' }, 
            { shape: [[1, 1, 0], [0, 1, 1]], color: '#00ff48' }, 
            { shape: [[0, 1, 1], [1, 1, 0]], color: '#ff3333' }, 
            { shape: [[1]], color: '#ffffff' }, 
            { shape: [[1, 1, 1]], color: '#3366ff' } 
        ];

        /* --- STATE PERSISTENCE --- */
        function saveGameState() {
            if (!isGameActive) return;
            const state = {
                grid: gameGrid,
                score: score,
                pieces: availablePieces,
                active: true
            };
            localStorage.setItem('bm3d_save', JSON.stringify(state));
        }

        function clearSavedGame() {
            localStorage.removeItem('bm3d_save');
        }

        function loadGameState() {
            const saved = localStorage.getItem('bm3d_save');
            return saved ? JSON.parse(saved) : null;
        }

        function loadHighScore() {
            const saved = localStorage.getItem('bm3dHighScore');
            highScore = saved ? parseInt(saved) : 0;
            displayHighScore = highScore;
            highScoreEl.textContent = highScore;
        }

        /* --- GAME LOGIC --- */

        function initGame(resume = false) {
            loadHighScore();
            
            const savedState = resume ? loadGameState() : null;

            if (savedState && resume) {
                gameGrid = savedState.grid;
                score = savedState.score;
                availablePieces = savedState.pieces;
                scoreEl.textContent = score;
                displayScore = score;
            } else {
                gameGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
                score = 0;
                displayScore = 0;
                scoreEl.textContent = '0';
                availablePieces = [];
                for(let i=0; i<3; i++) availablePieces.push(getRandomPiece());
                clearSavedGame();
                SoundManager.play('start');
            }

            isGameActive = true;
            currentDragInfo = null; 
            
            renderBoard();
            renderAllPieces(true); 
            checkMovesAvailability(); 
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            gameGrid.forEach((row, r) => {
                row.forEach((val, c) => {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    if (val) {
                        cell.style.backgroundColor = val;
                        cell.classList.add('occupied', 'block-3d'); 
                    }
                    boardEl.appendChild(cell);
                });
            });
        }

        function getRandomPiece() {
            return PIECES[Math.floor(Math.random() * PIECES.length)];
        }

        function updatePiecesAfterTurn(usedIndex) {
            availablePieces[usedIndex] = getRandomPiece();
            renderAllPieces(false, usedIndex);
            saveGameState(); 
            checkMovesAvailability(); 
        }

        function renderAllPieces(isStart = false, specificIndex = -1) {
            for (let i = 0; i < 3; i++) {
                const container = document.getElementById(`block-${i}`);
                container.classList.remove('unplayable');

                if(isStart || i === specificIndex) {
                    container.innerHTML = ''; 
                    const piece = availablePieces[i];
                    
                    const inner = document.createElement('div');
                    inner.className = 'preview-inner';
                    inner.classList.add('slide-up-enter');
                    
                    if(isStart) {
                        inner.style.animationDelay = `${i * 0.15}s`;
                    }

                    inner.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, 25px)`; 
                    
                    piece.shape.forEach(row => {
                        row.forEach(cell => {
                            const div = document.createElement('div');
                            div.className = 'preview-cell';
                            if (cell) {
                                div.style.backgroundColor = piece.color;
                                div.classList.add('block-3d'); 
                            }
                            inner.appendChild(div);
                        });
                    });
                    container.appendChild(inner);

                    container.onmousedown = (e) => startDrag(e, i, false);
                    container.ontouchstart = (e) => startDrag(e, i, true);
                }
            }
        }

        /* --- PREDICTION & GHOSTING --- */
        function checkMovesAvailability() {
            let anyMovePossible = false;
            
            availablePieces.forEach((piece, index) => {
                const container = document.getElementById(`block-${index}`);
                let canFit = false;

                for(let r=0; r<GRID_SIZE; r++) {
                    for(let c=0; c<GRID_SIZE; c++) {
                        if (canPlace(piece, r, c)) {
                            canFit = true;
                            break;
                        }
                    }
                    if(canFit) break;
                }

                if (!canFit) {
                    container.classList.add('unplayable');
                } else {
                    container.classList.remove('unplayable');
                    anyMovePossible = true;
                }
            });

            if (!anyMovePossible && availablePieces.length > 0) {
                gameOverRoutine();
            }
        }

        function gameOverRoutine() {
            isGameActive = false;
            clearSavedGame();
            setTimeout(() => {
                SoundManager.play('gameover');
                document.getElementById('final-score').textContent = score;
                document.getElementById('game-over-popup').classList.add('active');
            }, 800);
        }

        /* --- DRAG & DROP --- */
        let currentDragInfo = null; 
        let lastValidR = -1, lastValidC = -1;

        function getCurrentCellSize() {
            const cell = boardEl.querySelector('.grid-cell');
            return (!cell || cell.getBoundingClientRect().width === 0) ? boardEl.clientWidth / GRID_SIZE : cell.getBoundingClientRect().width;
        }

        function startDrag(e, index, isTouch) {
            if (!availablePieces[index] || !isGameActive) return;
            
            e.preventDefault(); 
            SoundManager.play('pickup');

            const container = document.getElementById(`block-${index}`);
            const piece = availablePieces[index];
            const cellSize = getCurrentCellSize();
            
            dragFollower.innerHTML = '';
            dragFollower.style.display = 'grid';
            dragFollower.className = ''; 
            
            if (container.classList.contains('unplayable')) {
                dragFollower.classList.add('faded');
            }

            dragFollower.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, ${cellSize}px)`;
            
            piece.shape.forEach(row => {
                row.forEach(cell => {
                    const div = document.createElement('div');
                    div.className = 'drag-cell';
                    div.style.width = `${cellSize}px`;
                    div.style.height = `${cellSize}px`;
                    if (cell) {
                        div.style.backgroundColor = piece.color;
                        div.classList.add('block-3d');
                    } else {
                        div.style.visibility = 'hidden';
                    }
                    dragFollower.appendChild(div);
                });
            });

            container.classList.add('hidden-source');

            currentDragInfo = { piece, index, isTouch, sourceContainer: container };
            
            const clientX = isTouch ? e.touches[0].clientX : e.clientX;
            const clientY = isTouch ? e.touches[0].clientY : e.clientY;
            
            moveFollower(clientX, clientY);
            
            if (isTouch) {
                document.addEventListener('touchmove', onDragMove, {passive: false});
                document.addEventListener('touchend', onDragEnd);
            } else {
                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('mouseup', onDragEnd);
            }
        }

        function onDragMove(e) {
            if (!currentDragInfo) return;
            e.preventDefault();
            const clientX = currentDragInfo.isTouch ? e.touches[0].clientX : e.clientX;
            const clientY = currentDragInfo.isTouch ? e.touches[0].clientY : e.clientY;
            moveFollower(clientX, clientY);
            checkGhost(clientX, clientY);
        }

        function moveFollower(x, y) {
            dragFollower.style.left = x + 'px';
            dragFollower.style.top = y + 'px';
        }

        function checkGhost(x, y) {
            document.querySelectorAll('.ghost').forEach(el => el.classList.remove('ghost'));
            
            const cellSize = getCurrentCellSize();
            const rect = boardEl.getBoundingClientRect();
            const piece = currentDragInfo.piece;

            const relativeX = x - rect.left - (piece.shape[0].length * cellSize / 2);
            const relativeY = y - rect.top - (piece.shape.length * cellSize) * 1.5; 

            const c = Math.round(relativeX / cellSize);
            const r = Math.round(relativeY / cellSize);

            if (canPlace(piece, r, c)) {
                lastValidR = r; lastValidC = c;
                drawGhost(piece, r, c);
            } else {
                lastValidR = -1; lastValidC = -1;
            }
        }

        function drawGhost(piece, r, c) {
            piece.shape.forEach((row, dy) => {
                row.forEach((val, dx) => {
                    if (val) {
                        const cell = document.querySelector(`.grid-cell[data-r="${r+dy}"][data-c="${c+dx}"]`);
                        if (cell) cell.classList.add('ghost');
                    }
                });
            });
        }

        function canPlace(piece, r, c) {
            for (let dy = 0; dy < piece.shape.length; dy++) {
                for (let dx = 0; dx < piece.shape[0].length; dx++) {
                    if (piece.shape[dy][dx]) {
                        const nr = r + dy;
                        const nc = c + dx;
                        if (nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE) return false;
                        if (gameGrid[nr][nc] !== 0) return false;
                    }
                }
            }
            return true;
        }

        function onDragEnd(e) {
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
            document.removeEventListener('touchmove', onDragMove);
            document.removeEventListener('touchend', onDragEnd);

            dragFollower.style.display = 'none';
            document.querySelectorAll('.ghost').forEach(el => el.classList.remove('ghost'));

            if(currentDragInfo && currentDragInfo.sourceContainer) {
                currentDragInfo.sourceContainer.classList.remove('hidden-source');
            }

            if (lastValidR !== -1) {
                placePiece(currentDragInfo.piece, lastValidR, lastValidC);
                updatePiecesAfterTurn(currentDragInfo.index);
            } else {
                SoundManager.play('error');
            }

            currentDragInfo = null;
            lastValidR = -1; lastValidC = -1;
        }

        function placePiece(piece, r, c) {
            SoundManager.play('drop'); 
            let blocks = 0;
            piece.shape.forEach((row, dy) => {
                row.forEach((val, dx) => {
                    if (val) {
                        gameGrid[r+dy][c+dx] = piece.color;
                        blocks++;
                    }
                });
            });
            addScore(blocks * 10);
            renderBoard();
            checkLines();
        }

        function checkLines() {
            let fullRows = [], fullCols = [];
            for(let r=0; r<GRID_SIZE; r++) {
                if(gameGrid[r].every(v => v !== 0)) fullRows.push(r);
            }
            for(let c=0; c<GRID_SIZE; c++) {
                let isFull = true;
                for(let r=0; r<GRID_SIZE; r++) if(gameGrid[r][c] === 0) isFull = false;
                if(isFull) fullCols.push(c);
            }

            if (fullRows.length > 0 || fullCols.length > 0) {
                SoundManager.play('blast');
                animateBlast(fullRows, fullCols);
            }
        }

        function animateBlast(rows, cols) {
            const cellsToClear = new Set();
            rows.forEach(r => {
                for(let c=0; c<GRID_SIZE; c++) cellsToClear.add(`${r},${c}`);
            });
            cols.forEach(c => {
                for(let r=0; r<GRID_SIZE; r++) cellsToClear.add(`${r},${c}`);
            });

            cellsToClear.forEach(key => {
                const [r, c] = key.split(',').map(Number);
                const cell = document.querySelector(`.grid-cell[data-r="${r}"][data-c="${c}"]`);
                if(cell) cell.classList.add('white-flash');
            });

            setTimeout(() => {
                cellsToClear.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    const cell = document.querySelector(`.grid-cell[data-r="${r}"][data-c="${c}"]`);
                    if(cell) cell.classList.add('spin-out');
                });
            }, 100);

            setTimeout(() => {
                rows.forEach(r => gameGrid[r].fill(0));
                cols.forEach(c => {
                    for(let r=0; r<GRID_SIZE; r++) gameGrid[r][c] = 0;
                });
                
                const total = rows.length + cols.length;
                addScore(total * 100, true);
                renderBoard(); 
                saveGameState();
                checkMovesAvailability(); 
            }, 600); 
        }

        function addScore(pts, isLine = false) {
            score += pts;
            
            // Check High Score
            if(score > highScore) {
                highScore = score;
                localStorage.setItem('bm3dHighScore', highScore);
                // Trigger High Score Animation
                animateHighScoreCounter();
            }
            
            floatingScore.textContent = isLine ? `+${pts}!` : `+${pts}`;
            floatingScore.classList.remove('score-animating');
            void floatingScore.offsetWidth;
            
            const rect = boardEl.getBoundingClientRect();
            floatingScore.style.left = (rect.left + rect.width/2 - 40) + 'px';
            floatingScore.style.top = (rect.top + rect.height/2 - 20) + 'px';
            floatingScore.classList.add('score-animating');

            animateScoreCounter();
        }

        function animateScoreCounter() {
            if(scoreAnimFrame) cancelAnimationFrame(scoreAnimFrame);
            const step = () => {
                const diff = score - displayScore;
                if (diff === 0) {
                    scoreEl.textContent = score;
                    return;
                }
                displayScore += Math.ceil(diff / 8);
                scoreEl.textContent = displayScore;
                scoreAnimFrame = requestAnimationFrame(step);
            };
            step();
        }

        // --- NEW: High Score Animation Function ---
        function animateHighScoreCounter() {
            if(highScoreAnimFrame) cancelAnimationFrame(highScoreAnimFrame);
            const step = () => {
                const diff = highScore - displayHighScore;
                if (diff === 0) {
                    highScoreEl.textContent = highScore;
                    return;
                }
                displayHighScore += Math.ceil(diff / 8);
                highScoreEl.textContent = displayHighScore;
                highScoreAnimFrame = requestAnimationFrame(step);
            };
            step();
        }

        /* --- NAVIGATION --- */
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        startBtn.onclick = () => {
            SoundManager.play('click');
            SoundManager.playMusic(); 

            showScreen('game-screen');
            const saved = loadGameState();
            if (saved && saved.active) {
                if(!isGameActive) initGame(true); // Resume
            } else {
                initGame(false); // New Game
            }
        };

        document.getElementById('pause-btn').onclick = () => {
            SoundManager.play('click');
            document.getElementById('pause-popup').classList.add('active');
        };

        document.getElementById('resume-btn').onclick = () => {
            SoundManager.play('click');
            document.getElementById('pause-popup').classList.remove('active');
        };

        document.getElementById('restart-btn-pause').onclick = () => {
            SoundManager.play('click');
            document.getElementById('pause-popup').classList.remove('active');
            initGame(false); 
        };

        document.getElementById('home-btn-pause').onclick = () => {
            SoundManager.play('click');
            document.getElementById('pause-popup').classList.remove('active');
            showScreen('home-screen');
        };

        document.getElementById('new-game-btn').onclick = () => {
            SoundManager.play('click');
            document.getElementById('game-over-popup').classList.remove('active');
            initGame(false);
        };

        document.getElementById('go-home-btn').onclick = () => {
            SoundManager.play('click');
            document.getElementById('game-over-popup').classList.remove('active');
            showScreen('home-screen');
        };

        document.getElementById('how-to-play-home-btn').onclick = () => {
            SoundManager.play('click');
            showScreen('game-screen');
            document.getElementById('how-to-play-popup').classList.add('active');
        };
        document.getElementById('how-to-ok-btn').onclick = () => {
            SoundManager.play('click');
            document.getElementById('how-to-play-popup').classList.remove('active');
            if (!isGameActive) showScreen('home-screen');
        };

        document.getElementById('sound-btn').onclick = function() {
            const isOn = SoundManager.toggleSound();
            this.querySelector('i').className = isOn ? 'fas fa-volume-up' : 'fas fa-volume-mute';
            SoundManager.play('click');
        };
        
        document.getElementById('music-btn').onclick = function() {
            const isOn = SoundManager.toggleMusic();
            if (isOn) {
                this.classList.remove('music-off');
            } else {
                this.classList.add('music-off');
            }
            SoundManager.play('click');
        };

        loadHighScore();
    </script>
</body>
</html>
